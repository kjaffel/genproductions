--- HToZATo2L2B_800p00_700p00_20p00_bbH4F_TuneCP5_13TeV-amcatnlo_pythia8/SubProcesses/reweight_xsec.f	2020-06-21 14:19:51.000000000 +0200
+++ HToZATo2L2B_800p00_700p00_20p00_bbH4F_TuneCP5_13TeV-amcatnlo_pythia8/SubProcesses/reweight_xsec.f	2021-04-20 19:19:42.966399030 +0200
@@ -18,31 +18,31 @@
       rwgt_muR_dep_fac = 1d0
 c     This is relevant for a muR-dependent bottom-mass in Yukawa.
       IF(wgtcpower .ne. 0d0 .and. runfac .eq. 1) THEN
-c$$$      vev    = 246.21845813429518469305d0 !vev in aMC@NLO from y_b->m_b
-c$$$      mbmb = MDL_YB*vev/dsqrt(2d0)
-c$$$com-- mbmb input for fixed Yukawa bmass in param_card.dat is used here
-c$$$com-- as start value of running and to remove it from the cross section
-c$$$c new settings NLO
-c$$$      apimZ  = alphas(MDL_MZ)/pi
-c$$$
-c$$$      if(dabs(scale/central-1d0).lt.tootiny) then
-c$$$c if scale muR is the same as the central scale of muR, get 
-c$$$c "input value" mb(muR) with highest possible accuracy
-c$$$         CALL runalpha(apimZ,MDL_MZ,central,4d0,4,0,apimuR)
-c$$$         CALL runalpha(apimZ,MDL_MZ,mbmb,4d0,4,0,apimb)
-c$$$         CALL runmass(mbmb,apimb,apimuR,4d0,4,mbmuR)
-c$$$      else
-c$$$c if scale and central are different (muR variations) do two steps:
-c$$$c step 1: get "input value" mb(central scale) from most accurate running
-c$$$         CALL runalpha(apimZ,MDL_MZ,central,4d0,4,0,apicentral)
-c$$$         CALL runalpha(apimZ,MDL_MZ,mbmb,4d0,4,0,apimb)
-c$$$         CALL runmass(mbmb,apimb,apicentral,4d0,4,mbcentral)
-c$$$c step 2: get variation around central value, ie mb(muR), with loop 
-c$$$c         order consistent with computation LO: 1-loop, NLO: 2-loop
-c$$$         CALL runalpha(apicentral,central,scale,4d0,2,0,apimuR)
-c$$$         CALL runmass(mbcentral,apicentral,apimuR,4d0,2,mbmuR)
-c$$$      endif
-c$$$      rwgt_muR_dep_fac = (mbmuR/mbmb)**wgtcpower
+      vev    = 246.21845813429518469305d0 !vev in aMC@NLO from y_b->m_b
+      mbmb = MDL_YB*vev/dsqrt(2d0)
+com-- mbmb input for fixed Yukawa bmass in param_card.dat is used here
+com-- as start value of running and to remove it from the cross section
+c new settings NLO
+      apimZ  = alphas(MDL_MZ)/pi
+
+      if(dabs(scale/central-1d0).lt.tootiny) then
+c if scale muR is the same as the central scale of muR, get 
+c "input value" mb(muR) with highest possible accuracy
+         CALL runalpha(apimZ,MDL_MZ,central,4d0,4,0,apimuR)
+         CALL runalpha(apimZ,MDL_MZ,mbmb,4d0,4,0,apimb)
+         CALL runmass(mbmb,apimb,apimuR,4d0,4,mbmuR)
+      else
+c if scale and central are different (muR variations) do two steps:
+c step 1: get "input value" mb(central scale) from most accurate running
+         CALL runalpha(apimZ,MDL_MZ,central,4d0,4,0,apicentral)
+         CALL runalpha(apimZ,MDL_MZ,mbmb,4d0,4,0,apimb)
+         CALL runmass(mbmb,apimb,apicentral,4d0,4,mbcentral)
+c step 2: get variation around central value, ie mb(muR), with loop 
+c         order consistent with computation LO: 1-loop, NLO: 2-loop
+         CALL runalpha(apicentral,central,scale,4d0,2,0,apimuR)
+         CALL runmass(mbcentral,apicentral,apimuR,4d0,2,mbmuR)
+      endif
+      rwgt_muR_dep_fac = (mbmuR/mbmb)**wgtcpower
       ELSE
          return
       ENDIF
